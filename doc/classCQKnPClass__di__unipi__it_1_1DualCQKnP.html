<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpathstylesheet.css.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>CQKnPClass_di_unipi_it</b>      </li>
      <li class="navelem"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html">DualCQKnP</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">DualCQKnP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Solver of Continuous Quadratic Knapsack Problems (CQKnP) based on the standard formulation of the dual problem as a piecewise-convex problem in the unique multiplier of the knapsack constraint and the corresponding obvious dual-ascent approach.  
 <a href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#details">More...</a></p>

<p><code>#include &lt;DualCQKnP.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DualCQKnP:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classCQKnPClass__di__unipi__it_1_1DualCQKnP.png" usemap="#DualCQKnP_map" alt=""/>
  <map id="DualCQKnP_map" name="DualCQKnP_map">
<area href="classCQKnPClass__di__unipi__it_1_1CQKnPClass.html" title="The class ContQKsk defines an interface for Continuous Quadratic Knapsack problems (CQKnP) solvers..." alt="CQKnPClass" shape="rect" coords="0,0,94,24"/>
<area href="classCQKnPClass__di__unipi__it_1_1ExDualCQKnP.html" title="Continuous Quadratic Knapsack Problems (CQKnP) solver derived from the DualCQKnP class (and therefore..." alt="ExDualCQKnP" shape="rect" coords="0,112,94,136"/>
</map>
 </div></div>

<p><a href="classCQKnPClass__di__unipi__it_1_1DualCQKnP-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f5e254c4f6acec0b114be38e5f538d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a8f5e254c4f6acec0b114be38e5f538d5">DualCQKnP</a> (const bool sort=true, const double eps=1e-6)</td></tr>
<tr class="memdesc:a8f5e254c4f6acec0b114be38e5f538d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most important operation for solving the CQKnP with a dual method is the sorting of the items for nondecreasing elements.  <a href="#a8f5e254c4f6acec0b114be38e5f538d5"></a><br/></td></tr>
<tr class="memitem:ab61c987069a5e5ba9dd9346fe61ae4a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ab61c987069a5e5ba9dd9346fe61ae4a9">SetSort</a> (const bool WhchSrt=false)</td></tr>
<tr class="memdesc:ab61c987069a5e5ba9dd9346fe61ae4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to change the sorting procedures to be used in the next calls to SolveKNP(); see the comments to the constructor for details.  <a href="#ab61c987069a5e5ba9dd9346fe61ae4a9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac900805a486cbb8489e3c176ed6e0d8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac900805a486cbb8489e3c176ed6e0d8e"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ac900805a486cbb8489e3c176ed6e0d8e">A</a></td></tr>
<tr class="memdesc:ac900805a486cbb8489e3c176ed6e0d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of lower bounds <br/></td></tr>
<tr class="memitem:a1b39cf581f9d74860fe3125ed4f16414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b39cf581f9d74860fe3125ed4f16414"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a1b39cf581f9d74860fe3125ed4f16414">B</a></td></tr>
<tr class="memdesc:a1b39cf581f9d74860fe3125ed4f16414"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of upper bounds <br/></td></tr>
<tr class="memitem:a1bedc710c5b077431fc8a8d7254c0751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bedc710c5b077431fc8a8d7254c0751"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a1bedc710c5b077431fc8a8d7254c0751">C</a></td></tr>
<tr class="memdesc:a1bedc710c5b077431fc8a8d7254c0751"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of linear costs <br/></td></tr>
<tr class="memitem:a8ae3099b44d89cd7f6d63a856e995600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ae3099b44d89cd7f6d63a856e995600"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a8ae3099b44d89cd7f6d63a856e995600">D</a></td></tr>
<tr class="memdesc:a8ae3099b44d89cd7f6d63a856e995600"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of quadratic costs <br/></td></tr>
<tr class="memitem:a1146fa7d0053d2cab6f8d0e75ac1e454"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1146fa7d0053d2cab6f8d0e75ac1e454"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a1146fa7d0053d2cab6f8d0e75ac1e454">McB</a></td></tr>
<tr class="memdesc:a1146fa7d0053d2cab6f8d0e75ac1e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">volume value <br/></td></tr>
<tr class="memitem:a89afbc18af45d9df325ffaff374624c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89afbc18af45d9df325ffaff374624c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a89afbc18af45d9df325ffaff374624c5">sense</a></td></tr>
<tr class="memdesc:a89afbc18af45d9df325ffaff374624c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sense of knapsack constraint <br/></td></tr>
<tr class="memitem:af5bfad8fcd15432cf66a4974055944d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5bfad8fcd15432cf66a4974055944d0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#af5bfad8fcd15432cf66a4974055944d0">LB</a></td></tr>
<tr class="memdesc:af5bfad8fcd15432cf66a4974055944d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower bound on dual variable <br/></td></tr>
<tr class="memitem:aabbaf59ed017b81836f0414c5b38f69d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabbaf59ed017b81836f0414c5b38f69d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#aabbaf59ed017b81836f0414c5b38f69d">UB</a></td></tr>
<tr class="memdesc:aabbaf59ed017b81836f0414c5b38f69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">upper bound on dual variable <br/></td></tr>
<tr class="memitem:affc1672db880d6ec046ec9a696948ef9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc1672db880d6ec046ec9a696948ef9"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#affc1672db880d6ec046ec9a696948ef9">I</a></td></tr>
<tr class="memdesc:affc1672db880d6ec046ec9a696948ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimal ordering <br/></td></tr>
<tr class="memitem:a66e0969d5185840cb75b369189de174f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66e0969d5185840cb75b369189de174f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a66e0969d5185840cb75b369189de174f">nSort</a></td></tr>
<tr class="memdesc:a66e0969d5185840cb75b369189de174f"><td class="mdescLeft">&#160;</td><td class="mdescRight">how many elements we have to sort <br/></td></tr>
<tr class="memitem:ac90bbb89785fb81c86bbb9caf21bfe8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac90bbb89785fb81c86bbb9caf21bfe8f"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ac90bbb89785fb81c86bbb9caf21bfe8f">OV</a></td></tr>
<tr class="memdesc:ac90bbb89785fb81c86bbb9caf21bfe8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">values upon which to order <br/></td></tr>
<tr class="memitem:ab9d07e6d3c68f3de87fce76b5f2eeddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9d07e6d3c68f3de87fce76b5f2eeddb"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ab9d07e6d3c68f3de87fce76b5f2eeddb">XSol</a></td></tr>
<tr class="memdesc:ab9d07e6d3c68f3de87fce76b5f2eeddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">primal solution <br/></td></tr>
<tr class="memitem:a0bd5879c34f002b80a89b63c76b0fe60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bd5879c34f002b80a89b63c76b0fe60"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a0bd5879c34f002b80a89b63c76b0fe60">muStar</a></td></tr>
<tr class="memdesc:a0bd5879c34f002b80a89b63c76b0fe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimal dual solution <br/></td></tr>
<tr class="memitem:aa062d4934413867ccd6af3cc18a82892"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa062d4934413867ccd6af3cc18a82892"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#aa062d4934413867ccd6af3cc18a82892">WSort</a></td></tr>
<tr class="memdesc:aa062d4934413867ccd6af3cc18a82892"><td class="mdescLeft">&#160;</td><td class="mdescRight">which sorting procedure is used <br/></td></tr>
<tr class="memitem:a8649bc1818f04fcbc265098ae0b9f557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8649bc1818f04fcbc265098ae0b9f557"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a8649bc1818f04fcbc265098ae0b9f557">OptVal</a></td></tr>
<tr class="memdesc:a8649bc1818f04fcbc265098ae0b9f557"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Optimal Value. <br/></td></tr>
<tr class="memitem:a6861c06ddf5e10f49fbfbdf870488af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6861c06ddf5e10f49fbfbdf870488af3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a6861c06ddf5e10f49fbfbdf870488af3">DefEps</a></td></tr>
<tr class="memdesc:a6861c06ddf5e10f49fbfbdf870488af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">precision required to construct the solution <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a58836388ccef44a62d2b9d6c94d605da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58836388ccef44a62d2b9d6c94d605da"></a>
static int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a58836388ccef44a62d2b9d6c94d605da">QSStck</a></td></tr>
<tr class="memdesc:a58836388ccef44a62d2b9d6c94d605da"><td class="mdescLeft">&#160;</td><td class="mdescRight">the stack to simulate recursive calls in QS <br/></td></tr>
<tr class="memitem:a19ce3dad2f2619fd4a23b0f422cb8a02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19ce3dad2f2619fd4a23b0f422cb8a02"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a19ce3dad2f2619fd4a23b0f422cb8a02">InstCntr</a></td></tr>
<tr class="memdesc:a19ce3dad2f2619fd4a23b0f422cb8a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of active instances <br/></td></tr>
<tr class="memitem:a9117c8634c4826a20eb6e903ee52d7ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9117c8634c4826a20eb6e903ee52d7ce"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#a9117c8634c4826a20eb6e903ee52d7ce">maxvl</a></td></tr>
<tr class="memdesc:a9117c8634c4826a20eb6e903ee52d7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">max value of items <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Solver of Continuous Quadratic Knapsack Problems (CQKnP) based on the standard formulation of the dual problem as a piecewise-convex problem in the unique multiplier of the knapsack constraint and the corresponding obvious dual-ascent approach. </p>
<p>This class is restricted to instances where <em>all</em> items have <em>strictly positive</em> quadratic costs and <em>finite</em> bounds (both lower and upper).</p>
<p>Derives from CQKnpClass and therefore it <em>mostly</em> conforms to its interface, except for refusing to solve instances without the required characteristics. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8f5e254c4f6acec0b114be38e5f538d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html">DualCQKnP</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sort</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The most important operation for solving the CQKnP with a dual method is the sorting of the items for nondecreasing elements. </p>
<p>2 * A[ i ] * D[ i ] + C[ i ] and 2 * B[ i ] * D[ i ] + C[ i ].</p>
<p>If the knapsack is a large one, this can be (relatively) time-consuming. Different sort procedures can be better in different situations, and the parameter 'sort' allows to decide which among the available sorting procedures has to be used. Possible values of this parameter are:</p>
<p>false Bubble Sort: this is O( n^2 ) on average, but it can be very fast - O( n ) - if reoptimizing from a previous problem where the order was not very different (e.g., only few costs have changed).</p>
<p>true [default] Quick Sort: this is O( n lg n ) on average and pretty efficient in practice, but can be very slow - O( n^2 ) - if the vector is already (almost) ordered, e.g. when reoptimizing from a previous problem where only few costs have changed.</p>
<p>The parameter Eps defines the precision required to construct the solution [default value is 1e-6].</p>
<p>The choices can be changed at any time with <a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ab61c987069a5e5ba9dd9346fe61ae4a9" title="Allows to change the sorting procedures to be used in the next calls to SolveKNP(); see the comments ...">SetSort()</a> and SetEps(), respectively [see below]. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab61c987069a5e5ba9dd9346fe61ae4a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#ab61c987069a5e5ba9dd9346fe61ae4a9">SetSort</a> </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>WhchSrt</em> = <code>false</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows to change the sorting procedures to be used in the next calls to SolveKNP(); see the comments to the constructor for details. </p>

<p>References <a class="el" href="classCQKnPClass__di__unipi__it_1_1DualCQKnP.html#aa062d4934413867ccd6af3cc18a82892">DualCQKnP::WSort</a>.</p>

</div>
</div>
</div><!-- contents -->
</body>
</html>
